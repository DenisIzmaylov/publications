Что у нас было

1. Обычные машинки, координаты которых мы получали раз в 15 секунд
2. Водительское приложение которое отдавала нам координаты раз в 15 секунд
3. Бэкэнд который нам выдавал координату раз в 15 секунд

Нужно было сделать чтобы машинка двигалась плавно.
Из за того что у нас большой разрыв между получением координат, появилась проблема что машинки ездили по домам, полям и т.д.
Чтобы не вмешиваться в водительскую прилу и не увеличивать нагрузку на сервер, и не увеличивать трафик отдаваемым водителем, было принято решение сделать все на стороне сервера и клиентского приложения.
И так как же мы получим точные координаты водителя , а никак…
В итоге долго думав мы сделали следующее:

1.
1.1 Со стороны сервера, выдавать фейковый маршрут зная последнюю реальную точку координат водителя
2.
2.1 Со стороны клиентского приложения, оставить запрос на получение координат так же раз в 15 секунд
2.2 При получение первой координаты водителя рисуем машинку
2.3 При получение последующих координат отправляем последнюю точку в до которой будет отрисовано плавное движение машинки
2.4 Получаем мы маршрут машинки в виде массива координат, и при движении маркера самая первая координата в массиве у нас будет той точкой по которой он движетс, и когда машинка начинала двигаться по этой координате мы её просто удаляли из массива
2.5  Помимо координат имеющихся, в клиентских приложениях нам нужно было вычислять время анимации машинки, т.е нужно было вычислить каждое движение маркера на карте между текущей и последующей координатами, это сделал так: взяли интервал времени за которые мы получаем координаты от сервера, и разделили их на количество координат которые у нас есть на текущее состояние.
2.4, 2.5 это все одна итерация, а координат то у нас много.

В итоге я сделал рекурсивную функцию которая вызывала саму себя и задавала заново вычисленное время анимации после удаление текущей координаты, а при получении новых координат от сервера мы их просто добавляли в конец массива в итоге получилось очень даже ничего

iOS - Использовал
```
     func moveDriverMarker(_ interval: Double) {
        if (!self.myDriverIterationCoordinate.isEmpty && self.myDriverMarker.map != nil) {
            тут мы запоминаем текущее положение маркера, и запоминаем его rotation

            if (self.myDriverMarker.position.latitude != myDriverIterationCoordinate.first!.latitude && self.myDriverMarker.position.longitude != myDriverIterationCoordinate.first!.longitude) {

                let dY = myDriverIterationCoordinate.first!.longitude - self.myDriverMarker.position.longitude

                let dX = myDriverIterationCoordinate.first!.latitude - self.myDriverMarker.position.latitude

                angle = atan2(dY, dX) * 180 / M_PI

Вычисление нового угла маркера в соотношение текущей его позиции и следующей координате по которой он начнет движение

            }

            CATransaction.begin()

            CATransaction.setAnimationDuration(0.3)

            self.myDriverMarker.rotation = angle

задаем угол поворота маркеру

            CATransaction.commit()

            CATransaction.begin()

            CATransaction.setCompletionBlock({

                if (!self.myDriverIterationCoordinate.isEmpty) {

                    self.myDriverIterationCoordinate.removeFirst()

Удаляем координату по которой у нас началось движение маркера

                    if (Double(self.myDriverIterationCoordinate.count) != 0.0) {

                        self.moveDriverMarker((22.0 - interval) / Double(self.myDriverIterationCoordinate.count))

Вызываем нашу функцию отрисовки заново

                    } else {

Если Координаты концились то мы ждем новых координат от сервара

                    }

                }

            })


            CATransaction.setAnimationDuration(interval)

Задаем интервал анимации маркера

            self.myDriverMarker.position = self.myDriverIterationCoordinate.first!

Задаем позицию маркера

            CATransaction.commit()

        } else {

Если Координаты концились то мы ждем новых координат от сервара

        }

    }
   ```
